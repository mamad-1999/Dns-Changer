package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os/exec"
	"strings"

	"github.com/fatih/color"
)

type DnsConfig struct {
	Name    string   `json:"name"`
	Servers []string `json:"servers"`
}

func main() {
	// Read the config.json file
	data, err := ioutil.ReadFile("config.json")
	if err != nil {
		fmt.Println("Error reading config.json:", err)
		return
	}

	var dnsConfigs []DnsConfig
	if err := json.Unmarshal(data, &dnsConfigs); err != nil {
		fmt.Println("Error parsing JSON:", err)
		return
	}

	// Display the DNS servers
	fmt.Println("Available DNS Servers:")
	for i, config := range dnsConfigs {
		color.Yellow("%d. %s", i+1, config.Name)
	}
	color.Yellow("0. Exit")

	// Get user input
	fmt.Print("Select a DNS server by number: ")
	var choice int
	fmt.Scan(&choice)

	if choice == 0 {
		color.Green("Exiting the program.")
		return
	}

	if choice < 1 || choice > len(dnsConfigs) {
		color.Red("Invalid choice. Please run the program again.")
		return
	}

	// Build the resolv.conf content
	selectedConfig := dnsConfigs[choice-1]
	var resolvContent strings.Builder
	resolvContent.WriteString("# Generated by Dns-changer\n")
	for _, server := range selectedConfig.Servers {
		resolvContent.WriteString(fmt.Sprintf("nameserver %s\n", server))
	}

	// Write to /etc/resolv.conf with sudo
	if err := writeToResolv(resolvContent.String()); err != nil {
		color.Red("Error writing to /etc/resolv.conf: %s", err)
		return
	}

	color.Green("Successfully changed DNS to %s", selectedConfig.Name)
}

func writeToResolv(content string) error {
	// Use sudo to write to /etc/resolv.conf
	cmd := exec.Command("sudo", "sh", "-c", fmt.Sprintf("echo '%s' > /etc/resolv.conf", content))
	return cmd.Run()
}
